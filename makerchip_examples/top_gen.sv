// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For $Cnt.
logic [15:0] L0_Cnt_n1,
             L0_Cnt_a0;

// For $reset.
logic L0_reset_a0;

// For |exe$adj_offset6.
logic [15:0] EXE_adj_offset6_a5;

// For |exe$aluop.
logic [3:0] EXE_aluop_a4,
            EXE_aluop_a5;

// For |exe$br.
logic EXE_br_a4,
      EXE_br_a5,
      EXE_br_a6;

// For |exe$cc.
logic [2:0] EXE_cc_a5,
            EXE_cc_a6;

// For |exe$dest.
logic [2:0] EXE_dest_a4,
            EXE_dest_a5,
            EXE_dest_a6;

// For |exe$fetch.
logic EXE_fetch_a6;

// For |exe$instr_valid.
logic EXE_instr_valid_a3,
      EXE_instr_valid_a4,
      EXE_instr_valid_a5,
      EXE_instr_valid_a6;

// For |exe$ir.
logic [15:0] EXE_ir_a3,
             EXE_ir_a4;

// For |exe$mar.
logic [15:0] EXE_mar_a5,
             EXE_mar_a6;

// For |exe$mdr.
logic [15:0] EXE_mdr_a5,
             EXE_mdr_a6;

// For |exe$mem_op.
logic EXE_mem_op_a6,
      EXE_mem_op_a7,
      EXE_mem_op_a8;

// For |exe$mem_rdata.
logic [15:0] EXE_mem_rdata_a6;

// For |exe$mem_resp.
logic EXE_mem_resp_a6;

// For |exe$offset6.
logic [5:0] EXE_offset6_a4,
            EXE_offset6_a5;

// For |exe$offset9.
logic [8:0] EXE_offset9_a4,
            EXE_offset9_a5,
            EXE_offset9_a6;

// For |exe$opcode.
logic [3:0] EXE_opcode_a4;

// For |exe$reg_a.
logic [15:0] EXE_reg_a_a4,
             EXE_reg_a_a5;

// For |exe$reg_b.
logic [15:0] EXE_reg_b_a4,
             EXE_reg_b_a5;

// For |exe$rslt.
logic [15:0] EXE_rslt_a5;

// For |exe$src1.
logic [2:0] EXE_src1_a4;

// For |exe$src2.
logic [2:0] EXE_src2_a4;

// For |exe$valid_br_taken.
logic EXE_valid_br_taken_a6;

// For |exe$valid_exe_inst.
logic EXE_valid_exe_inst_a6;

// For |exe$valid_ld.
logic EXE_valid_ld_a4,
      EXE_valid_ld_a5,
      EXE_valid_ld_a6;

// For |exe$valid_mem_instr.
logic EXE_valid_mem_instr_a4,
      EXE_valid_mem_instr_a5,
      EXE_valid_mem_instr_a6;

// For |exe$valid_st.
logic EXE_valid_st_a4,
      EXE_valid_st_a5,
      EXE_valid_st_a6,
      EXE_valid_st_a7;

// For |fetch$instr_valid.
logic FETCH_instr_valid_a1,
      FETCH_instr_valid_a2;

// For |fetch$pc.
logic [15:0] FETCH_pc_a0,
             FETCH_pc_a1;

// For |fetch$reset.
logic FETCH_reset_a0,
      FETCH_reset_a1,
      FETCH_reset_a2;

// For |fetch$valid_br_taken.
logic FETCH_valid_br_taken_a0;

// For |resp$FetchPending.
logic RESP_FetchPending_a1,
      RESP_FetchPending_a2,
      RESP_FetchPending_a3;

// For |resp$LoadPending.
logic RESP_LoadPending_a1,
      RESP_LoadPending_a2,
      RESP_LoadPending_a3;

// For |resp$StorePending.
logic RESP_StorePending_a1,
      RESP_StorePending_a2,
      RESP_StorePending_a3;

// For |resp$fetch_resp_valid.
logic RESP_fetch_resp_valid_a3;

// For |resp$ld_resp_valid.
logic RESP_ld_resp_valid_a3,
      RESP_ld_resp_valid_a4;

// For |resp$mem_rdata.
logic [15:0] RESP_mem_rdata_a2,
             RESP_mem_rdata_a3;

// For |resp$mem_resp.
logic RESP_mem_resp_a2,
      RESP_mem_resp_a3;

// For |resp$next_store_pending.
logic RESP_next_store_pending_a2;

// For |resp$reset.
logic RESP_reset_a1,
      RESP_reset_a2;


//
// Scope: |exe
//

// Clock signals.
logic clkP_EXE_instr_valid_a5 ;
logic clkP_EXE_instr_valid_a6 ;


   // Staging of $Cnt.
   always_ff @(posedge clk) L0_Cnt_a0[15:0] <= L0_Cnt_n1[15:0];


   //
   // Scope: |exe
   //

      // Staging of $aluop.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_aluop_a5[3:0] <= EXE_aluop_a4[3:0];

      // Staging of $br.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_br_a5 <= EXE_br_a4;
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_br_a6 <= EXE_br_a5;

      // Staging of $cc.
      always_ff @(posedge clk) EXE_cc_a6[2:0] <= EXE_cc_a5[2:0];

      // Staging of $dest.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_dest_a5[2:0] <= EXE_dest_a4[2:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_dest_a6[2:0] <= EXE_dest_a5[2:0];

      // Staging of $instr_valid.
      always_ff @(posedge clk) EXE_instr_valid_a4 <= EXE_instr_valid_a3;
      always_ff @(posedge clk) EXE_instr_valid_a5 <= EXE_instr_valid_a4;
      always_ff @(posedge clk) EXE_instr_valid_a6 <= EXE_instr_valid_a5;

      // Staging of $ir.
      always_ff @(posedge clk) EXE_ir_a4[15:0] <= EXE_ir_a3[15:0];

      // Staging of $mar.
      always_ff @(posedge clk) EXE_mar_a6[15:0] <= EXE_mar_a5[15:0];

      // Staging of $mdr.
      always_ff @(posedge clk) EXE_mdr_a6[15:0] <= EXE_mdr_a5[15:0];

      // Staging of $mem_op.
      always_ff @(posedge clk) EXE_mem_op_a7 <= EXE_mem_op_a6;
      always_ff @(posedge clk) EXE_mem_op_a8 <= EXE_mem_op_a7;

      // Staging of $offset6.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset6_a5[5:0] <= EXE_offset6_a4[5:0];

      // Staging of $offset9.
      always_ff @(posedge clkP_EXE_instr_valid_a5) EXE_offset9_a5[8:0] <= EXE_offset9_a4[8:0];
      always_ff @(posedge clkP_EXE_instr_valid_a6) EXE_offset9_a6[8:0] <= EXE_offset9_a5[8:0];

      // Staging of $reg_a.
      always_ff @(posedge clk) EXE_reg_a_a5[15:0] <= EXE_reg_a_a4[15:0];

      // Staging of $reg_b.
      always_ff @(posedge clk) EXE_reg_b_a5[15:0] <= EXE_reg_b_a4[15:0];

      // Staging of $valid_ld.
      always_ff @(posedge clk) EXE_valid_ld_a5 <= EXE_valid_ld_a4;
      always_ff @(posedge clk) EXE_valid_ld_a6 <= EXE_valid_ld_a5;

      // Staging of $valid_mem_instr.
      always_ff @(posedge clk) EXE_valid_mem_instr_a5 <= EXE_valid_mem_instr_a4;
      always_ff @(posedge clk) EXE_valid_mem_instr_a6 <= EXE_valid_mem_instr_a5;

      // Staging of $valid_st.
      always_ff @(posedge clk) EXE_valid_st_a5 <= EXE_valid_st_a4;
      always_ff @(posedge clk) EXE_valid_st_a6 <= EXE_valid_st_a5;
      always_ff @(posedge clk) EXE_valid_st_a7 <= EXE_valid_st_a6;



   //
   // Scope: |fetch
   //

      // Staging of $instr_valid.
      always_ff @(posedge clk) FETCH_instr_valid_a2 <= FETCH_instr_valid_a1;

      // Staging of $pc.
      always_ff @(posedge clk) FETCH_pc_a1[15:0] <= FETCH_pc_a0[15:0];

      // Staging of $reset.
      always_ff @(posedge clk) FETCH_reset_a1 <= FETCH_reset_a0;
      always_ff @(posedge clk) FETCH_reset_a2 <= FETCH_reset_a1;



   //
   // Scope: |resp
   //

      // Staging of $FetchPending.
      always_ff @(posedge clk) RESP_FetchPending_a2 <= RESP_FetchPending_a1;
      always_ff @(posedge clk) RESP_FetchPending_a3 <= RESP_FetchPending_a2;

      // Staging of $LoadPending.
      always_ff @(posedge clk) RESP_LoadPending_a2 <= RESP_LoadPending_a1;
      always_ff @(posedge clk) RESP_LoadPending_a3 <= RESP_LoadPending_a2;

      // Staging of $StorePending.
      always_ff @(posedge clk) RESP_StorePending_a2 <= RESP_StorePending_a1;
      always_ff @(posedge clk) RESP_StorePending_a3 <= RESP_StorePending_a2;

      // Staging of $ld_resp_valid.
      always_ff @(posedge clk) RESP_ld_resp_valid_a4 <= RESP_ld_resp_valid_a3;

      // Staging of $mem_rdata.
      always_ff @(posedge clk) RESP_mem_rdata_a3[15:0] <= RESP_mem_rdata_a2[15:0];

      // Staging of $mem_resp.
      always_ff @(posedge clk) RESP_mem_resp_a3 <= RESP_mem_resp_a2;

      // Staging of $reset.
      always_ff @(posedge clk) RESP_reset_a2 <= RESP_reset_a1;





//
// Gated clocks.
//



   //
   // Scope: |exe
   //

      clk_gate gen_clkP_EXE_instr_valid_a5(clkP_EXE_instr_valid_a5, clk, 1'b1, EXE_instr_valid_a4, 1'b0);
      clk_gate gen_clkP_EXE_instr_valid_a6(clkP_EXE_instr_valid_a6, clk, 1'b1, EXE_instr_valid_a5, 1'b0);





//
// Debug Signals
//

   if (1) begin : DEBUG_SIGS

      logic [15:0] \@-1$Cnt ;
      assign \@-1$Cnt = L0_Cnt_n1;
      logic  \@0$reset ;
      assign \@0$reset = L0_reset_a0;

      //
      // Scope: |exe
      //
      if (1) begin : \|exe 
         logic [15:0] \/@5$adj_offset6 ;
         assign \/@5$adj_offset6 = EXE_adj_offset6_a5;
         logic [3:0] \/?$instr_valid@4$aluop ;
         assign \/?$instr_valid@4$aluop = EXE_aluop_a4;
         logic  \/?$instr_valid@4$br ;
         assign \/?$instr_valid@4$br = EXE_br_a4;
         logic [2:0] \/@5$cc ;
         assign \/@5$cc = EXE_cc_a5;
         logic [2:0] \/?$instr_valid@4$dest ;
         assign \/?$instr_valid@4$dest = EXE_dest_a4;
         logic  \/@6$fetch ;
         assign \/@6$fetch = EXE_fetch_a6;
         logic  \/@3$instr_valid ;
         assign \/@3$instr_valid = EXE_instr_valid_a3;
         logic [15:0] \/@3$ir ;
         assign \/@3$ir = EXE_ir_a3;
         logic [15:0] \/@5$mar ;
         assign \/@5$mar = EXE_mar_a5;
         logic [15:0] \/@5$mdr ;
         assign \/@5$mdr = EXE_mdr_a5;
         logic  \/@6$mem_op ;
         assign \/@6$mem_op = EXE_mem_op_a6;
         logic [15:0] \/@6$mem_rdata ;
         assign \/@6$mem_rdata = EXE_mem_rdata_a6;
         logic  \/@6$mem_resp ;
         assign \/@6$mem_resp = EXE_mem_resp_a6;
         logic [5:0] \/?$instr_valid@4$offset6 ;
         assign \/?$instr_valid@4$offset6 = EXE_offset6_a4;
         logic [8:0] \/?$instr_valid@4$offset9 ;
         assign \/?$instr_valid@4$offset9 = EXE_offset9_a4;
         logic [3:0] \/?$instr_valid@4$opcode ;
         assign \/?$instr_valid@4$opcode = EXE_opcode_a4;
         logic [15:0] \/@4$reg_a ;
         assign \/@4$reg_a = EXE_reg_a_a4;
         logic [15:0] \/@4$reg_b ;
         assign \/@4$reg_b = EXE_reg_b_a4;
         logic [15:0] \/@5$rslt ;
         assign \/@5$rslt = EXE_rslt_a5;
         logic [2:0] \/?$instr_valid@4$src1 ;
         assign \/?$instr_valid@4$src1 = EXE_src1_a4;
         logic [2:0] \/?$instr_valid@4$src2 ;
         assign \/?$instr_valid@4$src2 = EXE_src2_a4;
         logic  \/@6$valid_br_taken ;
         assign \/@6$valid_br_taken = EXE_valid_br_taken_a6;
         logic  \/@6$valid_exe_inst ;
         assign \/@6$valid_exe_inst = EXE_valid_exe_inst_a6;
         logic  \/@4$valid_ld ;
         assign \/@4$valid_ld = EXE_valid_ld_a4;
         logic  \/@4$valid_mem_instr ;
         assign \/@4$valid_mem_instr = EXE_valid_mem_instr_a4;
         logic  \/@4$valid_st ;
         assign \/@4$valid_st = EXE_valid_st_a4;
      end

      //
      // Scope: |fetch
      //
      if (1) begin : \|fetch 
         logic  \/@1$instr_valid ;
         assign \/@1$instr_valid = FETCH_instr_valid_a1;
         logic [15:0] \/@0$pc ;
         assign \/@0$pc = FETCH_pc_a0;
         logic  \/@0$reset ;
         assign \/@0$reset = FETCH_reset_a0;
         logic  \/@0$valid_br_taken ;
         assign \/@0$valid_br_taken = FETCH_valid_br_taken_a0;
      end

      //
      // Scope: |resp
      //
      if (1) begin : \|resp 
         logic  \/@1$FetchPending ;
         assign \/@1$FetchPending = RESP_FetchPending_a1;
         logic  \/@1$LoadPending ;
         assign \/@1$LoadPending = RESP_LoadPending_a1;
         logic  \/@1$StorePending ;
         assign \/@1$StorePending = RESP_StorePending_a1;
         logic  \/@3$fetch_resp_valid ;
         assign \/@3$fetch_resp_valid = RESP_fetch_resp_valid_a3;
         logic  \/@3$ld_resp_valid ;
         assign \/@3$ld_resp_valid = RESP_ld_resp_valid_a3;
         logic [15:0] \/@2$mem_rdata ;
         assign \/@2$mem_rdata = RESP_mem_rdata_a2;
         logic  \/@2$mem_resp ;
         assign \/@2$mem_resp = RESP_mem_resp_a2;
         logic  \/@2$next_store_pending ;
         assign \/@2$next_store_pending = RESP_next_store_pending_a2;
         logic  \/@1$reset ;
         assign \/@1$reset = RESP_reset_a1;
      end


   end

